<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Stata中如何实现“字典”功能？ |
    
    明</title>
  
  <link rel="shortcut icon" href="/images/quill.svg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

  <link rel="stylesheet" href="/js/prism/prism.css">
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="明" type="application/atom+xml">
</head>

<body class="line-numbers">
  <main class="content">
    <section class="outer">
  <article id="post-stata_dict" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  Stata中如何实现“字典”功能？
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/stata_dict/" class="article-date">
  <time datetime="2022-03-15T16:00:00.000Z" itemprop="datePublished">2022-03-16</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>Stata语言在设计上完全以统计功能为核心，它并不以简洁的语法见长。不过，我们仍然可以用稍微复杂一点的代码，实现它不那么擅长的功能。</p>
<a id="more"></a>
<p>例如，我们想要进行一些一一对应的批量操作时，可以在Python等语言中构建<strong>字典（dictionary）</strong>变量。</p>
<p>通过<strong>循环语句</strong>和<strong>计数器暂元</strong>的结合使用，我们可以在Stata上实现类似功能。</p>
<h2 id="一、部分语句提供类似“字典”的语法"><a href="#一、部分语句提供类似“字典”的语法" class="headerlink" title="一、部分语句提供类似“字典”的语法"></a>一、部分语句提供类似“字典”的语法</h2><p>其实，有些语句的语法提供了类似的“一一对应”功能。例如，我们想要对变量进行批量重命名时，可以逐个重命名：</p>
<pre><code class="lang-STATA">sysuse nlsw88, clear
rename age 年龄
rename race 种族
rename married 婚姻状况
rename occupation 职业
</code></pre>
<p>也可以使用以下<strong>更简洁的代码</strong>：</p>
<pre><code class="lang-STATA">sysuse nlsw88, clear
rename (age race married occupation) (年龄 种族 婚姻状况 职业)
</code></pre>
<p>或者定义两个<strong>局部暂元</strong>（local macro），使得代码的逻辑更清晰：</p>
<pre><code class="lang-STATA">sysuse nlsw88, clear
local old_varnames age race married occupation
local new_varnames 年龄 种族 婚姻状况 职业
rename (`old_varnames&#39;) (`new_varnames&#39;)
</code></pre>
<p>当需要重命名的变量很多时，后两种写法有明显优势。</p>
<p>三种写法的运行结果是一致的：</p>
<p><img src="image-20220316094832045.png" alt="image-20220316094832045"></p>
<h2 id="二、手动构建“字典”"><a href="#二、手动构建“字典”" class="headerlink" title="二、手动构建“字典”"></a>二、手动构建“字典”</h2><p>但有些语句并不像<code>rename</code>语句一样支持这样的“一一对应”功能。例如，执行完上述代码之后，我们在Data Editor (Edit) 界面右击，选择“Data - Value labels - Manage value labels…”，发现值标签（value labels）的名字依然是旧的：</p>
<p><img src="image-20220316095133558.png" alt="image-20220316095133558"></p>
<p>这个时候，我们希望能把值标签的名字也同步更新（这在大型数据集中非常重要）。这需要使用<code>label copy</code>语句先复制一份原来的标签出来，然后再给新变量贴上新的值标签：</p>
<pre><code class="lang-STATA">sysuse nlsw88, clear
label copy racelbl 种族值标签
label copy marlbl 婚姻状况值标签
label copy occlbl 职业值标签
rename age 年龄
rename race 种族
rename married 婚姻状况
rename occupation 职业
label var 种族 种族值标签
label var 婚姻状况 婚姻状况值标签
label var 职业 职业值标签
</code></pre>
<p>这样就可以更方便地找到新变量名对应的值标签，当然，新的值标签和旧变量名对应的值标签是完全一致的：</p>
<p><img src="image-20220316095937568.png" alt="image-20220316095937568"></p>
<p>然而，<code>label copy</code>语句<strong>并不支持</strong><code>label copy (racelbl marlbl occlbl) (种族值标签 婚姻状况值标签 职业值标签)</code>这样的“一一对应”语法功能，只能一行行写重复的代码。当我们需要操作的值标签很多时，这就很耗时耗力。</p>
<p>一种常见的解决办法是<strong>使用其他工具</strong>（如Excel、Python或一些高级的代码编辑器）批量生成结构相同的Stata语句，再复制到do文件中。这种方法虽然可行，但并不优雅，而且会使后期对代码的勘误更加困难。</p>
<p>这时，我们可以结合<strong>循环语句</strong>和<strong>计数器暂元</strong>，完成想要的功能：</p>
<pre><code class="lang-STATA">sysuse nlsw88, clear
local old_varnames age race married occupation
local new_varnames 年龄 种族 婚姻状况 职业
local new_vars_with_val_labels 种族 婚姻状况 职业
local old_value_labels racelbl marlbl occlbl
local new_value_labels 种族值标签 婚姻状况值标签 职业值标签

// 复制变量值标签
local i = 0
foreach old in `old_value_labels&#39; &#123;
    local j = 0
    foreach new in `new_value_labels&#39; &#123;
        if `i&#39; == `j&#39; &#123;
            label copy `old&#39; `new&#39;
        &#125;
        local j = `j&#39; + 1
    &#125;
    local i = `i&#39; + 1
&#125;

// 重命名变量
rename (`old_varname&#39;) (`new_varname&#39;)

// 给重命名后的变量贴上新的值标签
local i = 0
foreach var of varlist `new_vars_with_val_labels&#39; &#123;
    local j = 0
    foreach val_label in `new_value_labels&#39; &#123;
        if `i&#39; == `j&#39; &#123;
            label var `var&#39; `val_label&#39;
        &#125;
        local j = `j&#39; + 1
    &#125;
    local i = `i&#39; + 1
&#125;
</code></pre>
<p>虽然在示例代码中，第二种写法比第一种还多了二十几行，但是第一种写法的代码行数和涉及的变量数量<strong>成正比</strong>，第二种写法的代码行数却<strong>不随变量数的增加而增加</strong>（除了在定义暂元时，为了避免单行过长而手动折行，可能会增加若干行）。当我们需要批量转换的变量有几十个、上百个乃至更多时，后一种的优势自然就体现出来了。</p>
<p>可以看到，这段代码实现了我们想要的功能：</p>
<p><img src="image-20220316102923884.png" alt="image-20220316102923884"></p>
<p>这里我们给值标签的起名字，都是变量名后面加上“值标签”三个字，所以我们还可以<strong>进一步精简</strong>上面的代码：</p>
<pre><code class="lang-STATA">sysuse nlsw88, clear
local old_varnames age race married occupation
local new_varnames 年龄 种族 婚姻状况 职业
local new_vars_with_val_labels 种族 婚姻状况 职业
local old_value_labels racelbl marlbl occlbl

local i = 0
foreach old in `old_value_labels&#39; &#123;
    local j = 0
    foreach new in `new_vars_with_val_labels&#39; &#123;
        if `i&#39; == `j&#39; &#123;
            label copy `old&#39; `new&#39;值标签
        &#125;
        local j = `j&#39; + 1
    &#125;
    local i = `i&#39; + 1
&#125;

rename (`old_varname&#39;) (`new_varname&#39;)

foreach var of varlist `new_vars_with_val_labels&#39; &#123;
    label var `var&#39; `var&#39;值标签
&#125;
</code></pre>
<h2 id="三、简析"><a href="#三、简析" class="headerlink" title="三、简析"></a>三、简析</h2><p>这里能实现类似“字典”功能，主要依靠两个循环结构的嵌套，以及两个计数器暂元<code>i</code>和<code>j</code>。</p>
<p>首先，外层循环遍历旧的值标签，每执行完一次循环体，计数器暂元<code>i</code>就增加1。换言之，<code>i</code>代表<strong>外层循环的循环体运行到了第几次</strong>：</p>
<pre><code class="lang-STATA">local i = 0
foreach old in `old_value_labels&#39; &#123;
    local j = 0
    foreach new in `new_value_labels&#39; &#123;
        if `i&#39; == `j&#39; &#123;
            label copy `old&#39; `new&#39;
        &#125;
        local j = `j&#39; + 1
    &#125;
    local i = `i&#39; + 1
&#125;
</code></pre>
<p>然后，内层循环遍历旧的值标签，每执行完一次循环体，计数器暂元<code>j</code>就增加1。同理，<code>j</code>代表<strong>内层循环的循环体运行到了第几次</strong>：</p>
<pre><code class="lang-STATA">local i = 0
foreach old in `old_value_labels&#39; &#123;
    local j = 0
    foreach new in `new_value_labels&#39; &#123;
        ...
        local j = `j&#39; + 1
    &#125;
    local i = `i&#39; + 1
&#125;
</code></pre>
<p>最后，为了完成“<strong>一一对应</strong>”，我们仅在<code>i</code>和<code>j</code>相等时进行复制值标签操作，即当且仅当：</p>
<ul>
<li>外层循环遍历至第1个旧的值标签，同时内层循环遍历至第1个新的值标签；或</li>
<li>外层循环遍历至第2个旧的值标签，同时内层循环遍历至第2个新的值标签；或</li>
<li>……</li>
<li>外层循环遍历至第n个旧的值标签，同时内层循环遍历至第n个新的值标签</li>
</ul>
<p>时，我们进行复制值标签操作：</p>
<pre><code class="lang-STATA">local i = 0
foreach old in `old_value_labels&#39; &#123;
    local j = 0
    foreach new in `new_value_labels&#39; &#123;
        if `i&#39; == `j&#39; &#123;
            label copy `old&#39; `new&#39;
        &#125;
        local j = `j&#39; + 1
    &#125;
    local i = `i&#39; + 1
&#125;
</code></pre>
<p>简而言之，当我们有两组内容，并且希望<strong>按顺序</strong>将这两组数据中对应的内容<strong>一一配对</strong>进行操作时，就可以使用上面的代码语法实现。这和Python等语言中“字典”变量的功能是类似的。</p>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="https://pku-zyf.github.io/stata_dict/" data-id="clegi0n1a000q4gvrerr0516f" class="article-share-link">
        分享
      </a>
      注释掉的是分享按钮。
      -->
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Stata/" rel="tag">Stata</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/da_xie_min_shi_shu/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      苏轼《答谢民师书》
      
    </div>
  </a>
  
  
  <a href="/anaconda_mirror/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">Anaconda北京外国语大学镜像源的使用</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
  
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
  
</section>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>明 &copy; 2023</li>
      
        <li></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
  <script src="/js/prism/prism.js" async></script>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/quill.svg" alt="明"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/atom.xml">RSS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>